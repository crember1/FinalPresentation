<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs–– -->
  <meta charset="utf-8">
  <title>MoD Final Presentation</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/customize.css">
  <script src='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css' rel='stylesheet' />
  <style>
  #map_1,#map_2,#map_3 {
    height: 500px;
  }
  hr {
  display: block;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  margin-left: auto;
  margin-right: auto;
  border-style: inset;
  border-width: 1px;
}
  </style>

  <!-- D3 v4 -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="http://vizjs.org/viz.v1.1.0.min.js"></script>

  <!-- Load color palette -->
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png">

</head>
<body>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h2>Hubway to Blue Bikes</h2>
      <p>
        ARCH 6306/6050, DSBA 6010, ITIS 8010/6010: Wednesdays 6pm-8:30pm, Taught Online
        <br>
        Anibal Robles Perez | Ryan Carriere | Brian Ferrell | Coral Rembert | https://www.bluebikes.com/
        <br>
        Advisor: Dr. Dimitris Papanikolaou | dpapanik@uncc.edu | Urban Synergetics Lab | https://urbansynergeticslab.net
      </p>
    <hr>
    </div>
    <div class="two columns">
    <!--<a href="https://www.bluebikes.com/" target="blank"><img class="scale-with-grid"src="img/bluebikes.jpg" height = "150" width = "300" style="float:right;"></a>-->
    <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="img/LabLogo_dark_cropped.png"></a>
    </div>
  </div>
  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h4>Introduction</h4>
      <p>
      In this project, we explore how the removal of the 30-minute free ride policy as a result of the rebranding of Boston’s bike-sharing system was reflected in user behavior. Boston’s bike-sharing system, Hubway, launched in July of 2011 with 610 bicycles and 61 stations covering a footprint of approximately 20 square miles in downtown Boston and its immediately surrounding neighborhoods. Brookline, Cambridge, and Somerville launched stations in 2012, and Hubway rides continued to grow exponentially. Before Hubway’s rebranding to Bluebikes, the system had expanded to include 185 stations with 1800 bicycles.</p>
    </div>
  </div>


<!-- <div style="width:610px; height:600px;float:left; margin: 10px; ">
  <h5>Hubway Station Locations (2017)</h5>
  <p>
    Hubway station locations in the Boston, Cambridge, Brookline, and Somerville areas as of 2017. Pre-Rebranding and Expansion.
  </p>
  <div id="map_1"></div>
</div> -->


<div class="container one-bottom">
  <h5>Blue Bike Station Locations (2019)</h5>
  <p>
    Hubway (red) and Blue Bike (blue) station locations with expanded station locations in existing station areas and the Everett, Mattapan, Roslindale, and Dorchester areas as of 2019. Post-Rebranding and Expansion.
  </p>
</div>
<div id="map_2"class="one-bottom"></div>

<div class="container one-bottom" style="clear: both;">
<p><br></p>
</div>
  
<div class="container one-bottom">
  <div class="twelve columns">
   <div>
  <h4>Expansion and Transformation</h4>
    <p>In 2017, Hubway announced a large expansion that would fill in the current network and expand to new neighboring areas including Everett, Mattapan, Roslindale, and Dorchester. In the following year, Blue Cross Blue Shield of Massachusetts sponsored the system and Hubway was rebranded to Blue Bikes with the addition of new stations and expansion to 3000 bikes. This project investigates the strategies that the service is using in its expansion with changes in pricing structure and additional stations. By analyzing trip data from June 2017 before the transition to Bluebikes and June 2019 after the expansion, we can visualize user behavior including trip duration, the stations with the most traffic, and the overall number of trips in the month.
    </p>
</div>

<div style="width:610px; height:600px;float:left; margin: 10px; ">
  <h5>Average Trip Duration INCREASES</h5>
  <p>Analysis of the average trip durations per month between 2017 and 2019. X axis is month, Y axis is time in minutes.</p>
  <button onclick="update(t17)">2017</button>
  <button onclick="update(t19)">2019</button>
  <div id="tripDurationBarGraph"></div>
</div>
<div>
  <h5>Significantly MORE Total Trips</h5>
  <p>Analysis of the total trips per month between 2017 and 2019. X axis is month, and Y axis is amount of trips.</p>
  <button onclick="updateTrip(b17)">2017</button>
  <button onclick="updateTrip(b19)">2019</button>
  <div id="totalTripsBarGraph"></div>
</div>

<div class="container one-bottom" >
  <p><br></p>
  </div>

  <div  class="container one-bottom"> 
    <div class="twelve columns">
      <h3>Long Trips</h3>
      <p>
      Sorts the trip data from June 2017 and June 2019 by highest trip duration and by station id, considering only "long" trips. These long trips are defined as being more than 30 minutes. Each station id and its corresponding location for each data set is shown in the maps above, In each heatmap, the x-axis represents the start location of the trip and the y axis represents the end location. Darker purple dots represent shorter trips, while lighter yellow dots represent longer trips.
      </p>
    <!-- </div>
  </div>
  <div class="container one-bottom">
    <div class="twelve columns"> -->
      <button onclick="updateHeatmap17('201706-longest-heatmap-sort-duration.csv')">2017 By highest trip duration.</button>
      <button onclick="updateHeatmap17('201706-longest-heatmap-sort-shortest.csv')">2017 By station id.</button>
      <button onclick="updateHeatmap17('201906-longest-heatmap-sort-duration.csv')">2019 By highest trip duration</button>
      <button onclick="updateHeatmap17('201906-longest-heatmap-sort-shortest.csv')">2019 By station id</button>
      <div id="heatmap"></div>
            <p>
        The Blue Bike rebranding gave users a way to travel longer distances for a cheaper price while Hubway preferred users to travel shorter distances. In the 2017, station ID heat map shows a few different patterns. Between start stations 10-74, the amount of trips are more dense at all the stations below the end station 80 which locations are Boston, Back Bay, multiple universities including Boston U, and Harvard Square. In 2019, there is a similiar pattern present but with the development of Blue Bikes more stations were added. With the additions of certain stations, Station 370 - Station 388 were add to the similiar areas including Boston, Back Bay, Harvard Square as well as an increases in stations around Cambridge. This allowed users to have many more locations to bike to from the populated areas across the bridge. 
        </p>
        <p >
          Another interesting pattern was the stations around Boston Logan Airport. The airport stations in both heat maps, have a very similiar pattern. Both do not show a significant amount of incoming and outgoing bike trips; however station 209 has a large amount of outgoing bike trips. After some investigation, station 209 is the one of the only area close enough to Boston Logan Internatioal Airport to grab a bite and then take a smooth bike ride home. As we were looking at the data, we found it hard to find a pattern in both maps sorted by trip duration. In both instances, there is a diagonal line of the longest trips but ends half-way up the map. There was one station we noticed in both instance that expresses unreasonable long trips, Station 1.  
        
        </p>
         
          
    </div>
  </div>
  
 <div class="container one-bottom">
  <div class="twelve columns">
   <div>
    <h4>Significantly MORE long trips</h4>
     <p>There were significantly more long trips being taken from the top two most popular stations in June of 2019 when compared to June of 2017. This can be attributed not only to the rise in popularity of Boston’s bike sharing system post-rebrand, but also to the expansion that occurred in further reaching residential areas</p>
     <iframe  src="https://kepler.gl/demo/map?mapUrl=https://dl.dropboxusercontent.com/s/1bksfvakm8vcc4z/keplergl_0ec8r59.json
      " style="border:0px #ffffff none;" name="myiFrame" scrolling="no" frameborder="1" marginheight="0px" marginwidth="0px" height="500px" width="1000px" allowfullscreen></iframe>
      <h5><br>Harvard Square at Mass Ave/ Dunster</h5>
      <p>Harvard Square at Mass Ave/ Dunster was the most popular station for long trips in both 2017 and 2019 because this station is the most accessible to Harvard University. Because of the locational relationship between this popular station and stations in newly accessible areas, trip durations are longer and more frequent. This is observed in the graph above, as 2019 has trips reaching the Dorchester and Everett areas. Expansion also occurred in areas that had existing stations and because of this, larger clusters of long trips are observed in both stations in 2019 when compared to 2017.</h5>
      </div>
      <div>
      <iframe  src="https://kepler.gl/demo/map?mapUrl=https://dl.dropboxusercontent.com/s/27u6q2qi14utpcs/keplergl_1jq0v2.json
      " style="border:0px #ffffff none;" name="myiFrame" scrolling="no" frameborder="1" marginheight="0px" marginwidth="0px" height="500px" width="1000px" allowfullscreen></iframe>
        <h5><br>Mugar Way at Beacon St</h5>
        <p>Mugar Way at Beacon St was the second most popular station for long trips in both 2017 and 2019 because this station is located at a popular tourist destination in the Boston area. There are significantly larger trip durations at this station in 2019 than in 2017, especially in the Boston and Cambridge areas. </p>
        </div>
      </div>
  </div>
<hr>
  
<div class="container one-bottom" >
  <h4 >Team & Contributions</h4>
  <h5 >Ryan Carriere</h5>
  <p >Ryan Carriere contributed to creating the heat maps, description and helping with the update function for it. He also contributed to parsing the data for the Kepler.gl graphs. He also contributed to the webpage layout and formating.</p>
  <h5>Coral Rembert</h5>
  <p>Coral Rembert contributed to creating the Github page, finding data and figuring out what data to represent, research question, page layout and narrative organization, kepler graphs, and text for kepler graphs.</p>
  <h5 >Anibal Robles</h5>
  <p >Anibal Robles contributed to parsing the csv files to get number of trips, trip duration, and trips per station (used in the interactive bar graphs). He also contributed by creating the bar graphs, adding the 2d maps, and creating the function for updating the heatmaps.</p>
  <h5 >Brian Ferrell</h5>
  <p >Brian Ferrell contributed to webpage layout, research, webpage text, parsing the data, and starting the research paper. </p>
</div>
<script>
// set the dimensions and margins of the graph
L.mapbox.accessToken = 'pk.eyJ1IjoiZGltcCIsImEiOiJkRnlra3RjIn0.E9CTYzNUEx0yb3dcfV4SiA';

var margin = {top: 200, right: 30, bottom: 200, left: 60},
  width = 650 - margin.left - margin.right,
  height = 600 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

//These are the variables that contain the id of the clicked station.
var stationId17 = 0;
var stationId19 = 0;
var currentData2017 = null;
var currentData2019 = null;

//Creation of both 2d maps (2017, 2019).
d3.csv("201706-hubway-tripdata.csv", function(tripData2017) {
  d3.csv("201906-bluebikes-tripdata.csv", function(tripData2019) {


    var parseTime = d3.timeParse("%Y-%m-%d %H:%M:%S");

    var stationNameArray = [];

    var trips2017 = tripData2017.map(function(aData)
    {
      var trip = {};

      //trip.starttime = d3.timeFormat("%Y-%m-%d %H:%M:%S");
      trip.starttime = parseTime(aData["starttime"].slice(0,-5));
      //trip.stoptime = d3.timeFormat("%Y-%m-%d %H:%M:%S")
      trip.stoptime = parseTime(aData["stoptime"].slice(0,-5));
      trip.duration = +aData["tripduration"];
      trip.start_station = +aData["start station id"];
      trip.end_station = +aData["end station id"];
      trip.start_station_name = aData["start station name"];
      trip.end_station_name = aData["end station name"];
      trip.start_station_lat = +aData["start station latitude"];
      trip.end_station_lat = +aData["end station latitude"];
      trip.start_station_lng = +aData["start station longitude"];
      trip.end_station_lng = +aData["end station longitude"];
      trip.bikeid = +aData["bikeid"];
      trip.usertype = aData["usertype"];

      stationNameArray.push(trip.start_station_name);

      return trip;
    });

    var trips2019 = tripData2019.map(function(aData)
    {
      var trip = {};

      //trip.starttime = d3.timeFormat("%Y-%m-%d %H:%M:%S").parse(aData["starttime"].slice(0,-5));
      trip.starttime = parseTime(aData["starttime"].slice(0,-5));
      //trip.stoptime = d3.timeFormat("%Y-%m-%d %H:%M:%S").parse(aData["stoptime"].slice(0,-5));
      trip.stoptime = parseTime(aData["stoptime"].slice(0,-5));
      trip.duration = +aData["tripduration"];
      trip.start_station = +aData["start station id"];
      trip.end_station = +aData["end station id"];
      trip.start_station_name = aData["start station name"];
      trip.end_station_name = aData["end station name"];
      trip.start_station_lat = +aData["start station latitude"];
      trip.end_station_lat = +aData["end station latitude"];
      trip.start_station_lng = +aData["start station longitude"];
      trip.end_station_lng = +aData["end station longitude"];
      trip.bikeid = +aData["bikeid"];
      trip.usertype = aData["usertype"];
      
      return trip;
    });

    // Only getting the information needed from csv file (parsing even more).
    stations2017 = getStationsFromTrips(trips2017);
    stations2019 = getStationsFromTrips(trips2019);

/*     var map_1 = L.mapbox.map('map_1')
      .setView([42.3601,-71.0589], 12)
      .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10'));
      map_1
      .scrollWheelZoom.disable();

    stations2017.forEach(function(station){
      
      //Creating a layer for the markers to be able to get the 'event' when they are clicked.
      //Sourced from: 
      //https://gis.stackexchange.com/a/172586 
      var markersLayer = L.featureGroup().addTo(map_1);
      station.lat = +station.lat;
      station.lng = +station.lng;
      
      var path_options = {};

      path_options = {
        radius :  6,
        color : d3.rgb(16,52,166).brighter(),
        stroke: true,
        weight : 1,
        fill : true,
        Color: d3.rgb(16,52,166).brighter(),
      };

      L.circleMarker([station.lat, station.lng], path_options).addTo(markersLayer).bindPopup(
          "Station Name: " + station.name 
          + "<br>Station ID: </br>" + station.station_id);  

      markersLayer.on("click", function (event) {
        var clickedMarker = event.layer;
        console.log(station.station_id);
        stationId17 = station.station_id;
      });
      
      /* L.circleMarker([station.lat, station.lng], path_options).addTo(markersLayer).bindPopup(
      station.station_id);
      markersLayer.on("click", function (event) {
          var clickedMarker = event.layer;
          console.log(clickedMarker)
      }); /
    }); */

    var map_2 = L.mapbox.map('map_2')
      .setView([42.3601,-71.0589], 12)
      .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10'));
      map_2
      .scrollWheelZoom.disable();

    stations2019.forEach(function(station){
      
      //Creating a layer for the markers to be able to get the 'event' when they are clicked.
      //Sourced from: 
      //https://gis.stackexchange.com/a/172586 
      var markersLayer = L.featureGroup().addTo(map_2);
      station.lat = +station.lat;
      station.lng = +station.lng;
      
      var path_options = {};

      if(stationNameArray.includes(station.name))
      {
        path_options = {
          radius :  6,
          color : d3.rgb(166,16,16).brighter(),
          stroke: true,
          weight : 1,
          fill : true,
          Color: d3.rgb(166,16,16).brighter(),
        };
      }
      else
      {
        path_options = {
          radius :  6,
          color : d3.rgb(16,52,166).brighter(),
          stroke: true,
          weight : 1,
          fill : true,
          Color: d3.rgb(16,52,166).brighter(),
        };
      }
      

      L.circleMarker([station.lat, station.lng], path_options).addTo(markersLayer).bindPopup(
          "Station Name: " + station.name 
          + "<br>Station ID: </br>" + station.station_id);  

      markersLayer.on("click", function (event) {
        var clickedMarker = event.layer;
        console.log(station.station_id);
        stationId19 = station.station_id;
      });
      
    });

  });
});

/* d3.csv("201906 - longest.csv", function(data) {


    var nodeNames = data.map(function(d){return d.name})

    var id = data.map(function(d){return d.id})

    var size = d3.scaleLinear()
      .domain([1,30])
      .range([2,30]);

    var x = d3.scalePoint()
      .range([0, width])
      .domain(nodeNames)

      var idToNode = {};
      data.forEach(function (n) {
        idToNode[n.id] = n;
      });


      // Add the links
      var links = svg
        .selectAll('mylinks')
        .data(data)
        .enter()
        .append('path')
        .attr('d', function (d) {
          start = x(idToNode[d.source].name)    // X position of start node on the X axis
          end = x(idToNode[d.target].name)      // X position of end node
          return ['M', start, height-30,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
            'A',                            // This means we're gonna build an elliptical arc
            (start - end)/2, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
            (start - end)/2, 0, 0, ',',
            start < end ? 1 : 0, end, ',', height-30] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
            .join(' ');
        })
        .style("fill", "none")
        .attr("stroke", "grey")
        .style("stroke-width", 1)


        var allID = data.map(function(d){return d.id})
        allID = [...new Set(allID)]

        var color = d3.scaleOrdinal()
          .domain(allID)
          .range(d3.schemeSet3);

        var nodes = svg
          .selectAll("mynodes")
          .data(data.sort(function(a,b) { return +b.n - +a.n }))
          .enter()
          .append("circle")
            .attr("cx", function(d){ return(x(d.name))})
            .attr("cy", height-30)
            .attr("r", function(d){ return(size(d.weight))})
            //.style("fill", function(d){ return color(d.id)})
            .attr("stroke", "white")

            var labels = svg
              .selectAll("mylabels")
              .data(data)
              .enter()
              .append("text")
                .attr("x", 0)
                .attr("y", 0)
                .text(function(d){ return(d.name)} )
                .style("text-anchor", "end")
                .attr("transform", function(d){ return( "translate(" + (x(d.name)) + "," + (height-15) + ")rotate(-45)")})
                .style("font-size", 6)

                nodes
                  .on('mouseover', function (d) {
                    // Highlight the nodes: every node is green except of him
                    nodes
                      .style('opacity', .2)
                    d3.select(this)
                      .style('opacity', 1)
                    // Highlight the connections
                    links
                      .style('stroke', function (link_d) { return link_d.source === d.id || link_d.target === d.id ? color(d.id) : '#b8b8b8';})
                      .style('stroke-opacity', function (link_d) { return link_d.source === d.id || link_d.target === d.id ? 1 : .2;})
                      .style('stroke-width', function (link_d) { return link_d.source === d.id || link_d.target === d.id ? 4 : 1;})
                    labels
                      .style("font-size", function(label_d){ return label_d.name === d.name ? 16 : 2 } )
                      .attr("y", function(label_d){ return label_d.name === d.name ? 10 : 0 } )

                  })
                  .on('mouseout', function (d) {
                    nodes.style('opacity', 1)
                    links
                      .style('stroke', 'grey')
                      .style('stroke-opacity', .8)
                      .style('stroke-width', '1')
                    labels
                      .style("font-size", 4 )

                  })

}); */

var t17 = null;
var t19 = null;
var b17 = null;
var b19 = null;

// Average times, create bar graphs.
d3.csv("averageTimePerMonth_2017.csv", function(trip_2017Data){
  d3.csv("averageTimePerMonth_2019.csv", function(trip_2019Data){   
    var t1 = trip_2017Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    var t2 = trip_2019Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    
    t17 = t1
    t19 = t2
    update(t17)
  });
});

// Average times, create bar graphs.
d3.csv("totalTripsPerMonth_2017.csv", function(trip_2017Data){
  d3.csv("totalTripsPerMonth_2019.csv", function(trip_2019Data){   
    var t1 = trip_2017Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    var t2 = trip_2019Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    
    b17 = t1
    b19 = t2
    updateTrip(b17)
  });
});
//From: https://stackoverflow.com/a/56216283 
/* (async() => {
    console.log("waiting for variable");
    while(!window.hasOwnProperty("t17") || !window.hasOwnProperty("t19")) // define the condition as you like
        await new Promise(resolve => setTimeout(resolve, 1000));
    console.log("variable is defined");
})();
console.log("above code doesn't block main function stack"); */

// set the dimensions and margins of the graph
var barMargin = {top: 30, right: 30, bottom: 70, left: 60},
    barWidth = 460 - barMargin.left - barMargin.right,
    barHeight = 400 - barMargin.top - barMargin.bottom;


// append the svg object to the body of the page
var barSvg = d3.select("#tripDurationBarGraph")
  .append("svg")
    .attr("width", barWidth + barMargin.left + barMargin.right)
    .attr("height", barHeight + barMargin.top + barMargin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + barMargin.left + "," + barMargin.top + ")");

// append the svg object to the body of the page
var barSvg2 = d3.select("#totalTripsBarGraph")
  .append("svg")
    .attr("width", barWidth + barMargin.left + barMargin.right)
    .attr("height", barHeight + barMargin.top + barMargin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + barMargin.left + "," + barMargin.top + ")");


// Initialize the X axis
var barX = d3.scaleBand()
  .range([ 0, barWidth ])
  .padding(0.2);
var barXAxis = barSvg.append("g")
  .attr("transform", "translate(0," + barHeight + ")")

// Initialize the Y axis
var barY = d3.scaleLinear()
  .range([ barHeight, 0]);
var barYAxis = barSvg.append("g")
  .attr("class", "myYaxis")


// Initialize the X axis
var barX2 = d3.scaleBand()
  .range([ 0, barWidth ])
  .padding(0.2);
var barXAxis2 = barSvg2.append("g")
  .attr("transform", "translate(0," + barHeight + ")")

// Initialize the Y axis
var barY2 = d3.scaleLinear()
  .range([ barHeight, 0]);
var barYAxis2 = barSvg2.append("g")
  .attr("class", "myYaxis")

  // A function that create / update the plot for a given variable:
  function update(data) {

    console.log(data)
    // Update the X axis
    barX.domain(data.map(function(d) { return d.month; }))
    barXAxis.call(d3.axisBottom(barX))

    // Update the Y axis
    barY.domain([0, 60]);//d3.max(data, function(d) { return d.value }) ]);
    barYAxis.transition().duration(1000).call(d3.axisLeft(barY));

    // Create the u variable
    var u = barSvg.selectAll("rect")
      .data(data)

    u
      .enter()
      .append("rect") // Add a new rect for each new elements
      .merge(u) // get the already existing elements as well
      .transition() // and apply changes to all of them
      .duration(1000)
        .attr("x", function(d) { return barX(d.month); })
        .attr("y", function(d) { return barY(d.value); })
        .attr("width", barX.bandwidth())
        .attr("height", function(d) { return barHeight - barY(d.value); })
        .attr("fill", "#8355ed")

      // If less group in the new dataset, I delete the ones not in use anymore
      u
      .exit()
      .remove()
  }
  function waitForElement(){
    if((typeof t17 !== "undefined") || (typeof t19 !== "undefined")){
        //variable exists, do what you want
        return;
    }
    else{
        setTimeout(waitForElement, 250);
    }
  }

  // A function that create / update the plot for a given variable:
  function updateTrip(data) {

      console.log(data)
      // Update the X axis
      barX2.domain(data.map(function(d) { return d.month; }))
      barXAxis2.call(d3.axisBottom(barX2))

      // Update the Y axis
      barY2.domain([0, 400000]);//d3.max(data, function(d) { return d.value }) ]);
      barYAxis2.transition().duration(1000).call(d3.axisLeft(barY2));

      // Create the u variable
      var u = barSvg2.selectAll("rect")
        .data(data)

      u
        .enter()
        .append("rect") // Add a new rect for each new elements
        .merge(u) // get the already existing elements as well
        .transition() // and apply changes to all of them
        .duration(1000)
          .attr("x", function(d) { return barX2(d.month); })
          .attr("y", function(d) { return barY2(d.value); })
          .attr("width", barX2.bandwidth())
          .attr("height", function(d) { return barHeight - barY2(d.value); })
          .attr("fill", "#8355ed")

        // If less group in the new dataset, I delete the ones not in use anymore
        u
        .exit()
        .remove()
      }
  function waitForElement2(){
    if((typeof b17 !== "undefined") || (typeof b19 !== "undefined")){
        //variable exists, do what you want
        return;
    }
    else{
        setTimeout(waitForElement2, 250);
    }
  } 

  function getStationsFromTrips(trips){
          var stations = [];
          var indexByStationName = d3.map();
          var StationNameByIndex = d3.map();
          var n = 0;
          trips.forEach(function(trip) {
            
            if (!indexByStationName.has(trip.start_station)) {
              stations.push({
                station_id : trip.start_station,
                name : trip.start_station_name,
                lat : trip.start_station_lat,
                lng : trip.start_station_lng,
              });
              StationNameByIndex.set(n, trip.start_station);
              indexByStationName.set(trip.start_station, n++);
            }
            if (!indexByStationName.has(trip.end_station)) {
              stations.push({
                station_id : trip.end_station,
                name : trip.end_station_name,
                lat : trip.end_station_lat,
                lng : trip.end_station_lng,
              });
              StationNameByIndex.set(n, trip.end_station);
              indexByStationName.set(trip.end_station, n++);
            }

          });
          number_of_stations = n;
          return stations;
        }

  // Initialize the plot with the first dataset
  waitForElement()
  
var heatMargin = {top: 30, right: 30, bottom: 70, left: 70},
  heatWidth = 950 - heatMargin.left - heatMargin.right,
  heatHeight = 900 - heatMargin.top - heatMargin.bottom;

// append the svg object to the body of the page
var heatSvg = d3.select("#heatmap")
.append("svg")
  .attr("width", heatWidth + heatMargin.left + heatMargin.right)
  .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
.append("g")
  .attr("transform",
        "translate(" + heatMargin.left + "," + heatMargin.top + ")");


//Read the data
d3.csv("201706-longest-heatmap.csv", function(heat_2017data) {

  // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
  var myGroups = d3.map(heat_2017data, function(d){return d.start_station_id;}).keys()
  var myVars = d3.map(heat_2017data, function(d){return d.end_station_id;}).keys()

  // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
    heatSvg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
    heatSvg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0)) 

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  heatSvg.selectAll()
    .data(heat_2017data, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseleave", mouseleave)

  });
  //updateHeatmap17("201706-longest-heatmap.csv");
 
  
  
  //Heatmap2
  function updateHeatmap17(fileName)
{
  document.getElementById("heatmap").innerHTML = ""; 
  // set the dimensions and margins of the graph
var heatMargin = {top: 30, right: 30, bottom: 70, left: 70},
  heatWidth = 950 - heatMargin.left - heatMargin.right,
  heatHeight = 900 - heatMargin.top - heatMargin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#heatmap")
.append("svg")
  .attr("width", heatWidth + heatMargin.left + heatMargin.right)
  .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
.append("g")
  .attr("transform",
        "translate(" + heatMargin.left + "," + heatMargin.top + ")");

//Read the data
d3.csv(fileName, function(heat_2019data) {


  // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
  var myGroups = d3.map(heat_2019data, function(d){return d.start_station_id;}).keys()
  var myVars = d3.map(heat_2019data, function(d){return d.end_station_id;}).keys()

  // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
  svg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
  svg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0))
    
    

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  svg.selectAll()
    .data(heat_2019data, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseleave", mouseleave)

});
}      
// https://bl.ocks.org/iblind/b394c943fef0aedc569d 
function updateHeatmap17(fileName)
{
  document.getElementById("heatmap").innerHTML = "";
  // append the svg object to the body of the page
  var heatSvg = d3.select("#heatmap")
  .append("svg")
    .attr("width", heatWidth + heatMargin.left + heatMargin.right)
    .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + heatMargin.left + "," + heatMargin.top + ")");
  //Get data, in this case, sorting csv file.
  d3.csv(fileName, function(heat17) {
    myGroups = d3.map(heat17, function(d){return d.start_station_id;}).keys()
    myVars = d3.map(heat17, function(d){return d.end_station_id;}).keys()

     // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
    heatSvg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
    heatSvg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0)) 

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  heatSvg.selectAll()
    .data(heat17, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .transition().duration(100)
      .style("fill", function(d) { return myColor(d.tripduration)} )
      //.style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)

    
  });
}

// https://bl.ocks.org/iblind/b394c943fef0aedc569d 
function updateHeatmap17(fileName)
{
  document.getElementById("heatmap").innerHTML = "";
  // append the svg object to the body of the page
var svg = d3.select("#heatmap")
.append("svg")
  .attr("width", heatWidth + heatMargin.left + heatMargin.right)
  .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
.append("g")
  .attr("transform",
        "translate(" + heatMargin.left + "," + heatMargin.top + ")");
  //Get data, in this case, sorting csv file.
  d3.csv(fileName, function(heat19) {
    myGroups = d3.map(heat19, function(d){return d.start_station_id;}).keys()
    myVars = d3.map(heat19, function(d){return d.end_station_id;}).keys()

  // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
  svg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
  svg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0))
    

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap2")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  svg.selectAll()
    .data(heat19, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseleave", mouseleave)

    
  });
}

function updateByStationIndex(anIndex)
{
  
}

</script>


  </body>
  </html>
