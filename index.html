<!DOCTYPE html>
<html lang="en">
<head>

  <!-- Basic Page Needs–– -->
  <meta charset="utf-8">
  <title>MoD Final Presentation</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT -->
  <link href="https://fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.10.2/css/all.min.css">

  <!-- CSS -->
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/skeleton.css">
  <link rel="stylesheet" href="css/customize.css">
  <script src='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.js'></script>
  <link href='https://api.mapbox.com/mapbox.js/v3.3.1/mapbox.css' rel='stylesheet' />
  <style>
  #map_1,#map_2,#map_3 {
    height: 500px;
  }
  hr {
  display: block;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  margin-left: auto;
  margin-right: auto;
  border-style: inset;
  border-width: 1px;
}
  </style>

  <!-- D3 v4 -->
  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="http://vizjs.org/viz.v1.1.0.min.js"></script>

  <!-- Load color palette -->
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="images/favicon.png">

</head>
<body>

  <div class="container one-bottom" style="margin-top: 50px">
    <div class="ten columns">
      <h2>Hubway to Blue Bikes</h2>
      <h4>What was the impact of re-branding on Boston's bike share system regarding trip duration?</h4>
      <p>
        ARCH 6306/6050, DSBA 6010, ITIS 8010/6010: Wednesdays 6pm-8:30pm, Taught Online
        <br>
        Anibal Robles Perez | Ryan Carriere | Brian Ferrell | Coral Rembert | https://www.bluebikes.com/
        <br>
        Advisor: Dr. Dimitris Papanikolaou | dpapanik@uncc.edu | Urban Synergetics Lab | https://urbansynergeticslab.net
      </p>
    <hr>
    <h6>Navigation Buttons:</h6>
    <nav>
      <ul>
        <li><a style="color:blue" href="index.html"><b>Home</b></a></li>
        <li><a style="color:blue" href="kepler.html">Kepler Graph</a></li>
      </ul>
    </nav>
    </div>
    <div class="two columns">
    <!--<a href="https://www.bluebikes.com/" target="blank"><img class="scale-with-grid"src="img/bluebikes.jpg" height = "150" width = "300" style="float:right;"></a>-->
    <a href="https://urbansynergeticslab.net/"><img class="scale-with-grid" src="img/LabLogo_dark_cropped.png"></a>
    </div>
  </div>


 <!--  <div class="container one-bottom" style="margin-top: 50px">
    <div>
      <h3>Arc Graph</h3>
      <iframe src="https://kepler.gl/demo/map?mapUrl=https://dl.dropboxusercontent.com/s/4eqam699917sd7b/keplergl_ciwawbl.json" style="border:0px #ffffff none; float:left" name="myiFrame" scrolling="no" frameborder="1" marginheight="0px" marginwidth="0px" height="700px" width="800px" allowfullscreen><
    </div>
  </div> -->

   

<div style="width:610px; height:600px;float:left; margin: 10px; ">
  <p>
    Hubway station (2017) locations in the Boston, Cambridge, Brookline, and Somerville areas as of 2017. Pre-expansion.
  </p>


  <div id="map_1"></div>
</div>
<div style="width:610px; height:600px;float:left; margin: 10px;">
  <p>
    Hubway station (2019) locations in the Boston, Cambridge, Brookline, and Somerville areas as of 2017. Pre-expansion.
  </p>
 <div id="map_2"></div>
</div>

<div class="container one-bottom" >
<p><br></p>
</div>


<div style="width:610px; height:600px;float:left; margin: 10px; ">
  <p>Bar graph displaying the average trip duration per month. X axis is month, Y axis is time in minutes.</p>
  <button onclick="update(t17)">2017</button>
  <button onclick="update(t19)">2019</button>
  <div id="tripDurationBarGraph"></div>
</div>
<div style="width:610px; height:600px;float:left; margin: 10px; ">
  <p>Bar graph displaying the total trips per month. X axis is month, Y axis is amount of trips.</p>
  <button onclick="updateTrip(b17)">2017</button>
  <button onclick="updateTrip(b19)">2019</button>
  <div id="totalTripsBarGraph"></div>
</div>

<div class="container one-bottom" >
  <p><br></p>
  </div>

<p>Sorting: </p>
<button onclick="updateHeatmap17('201706-longest-heatmap-sort-duration.csv')">2017 By highest trip duration.</button>
<button onclick="updateHeatmap17('201706-longest-heatmap-sort-shortest.csv')">2017 By station id.</button>
<button onclick="updateHeatmap17('201906-longest-heatmap-sort-duration.csv')">2019 By highest trip duration</button>
<button onclick="updateHeatmap17('201906-longest-heatmap-sort-shortest.csv')">2019 By station id</button>
<div id="heatmap"></div>

<hr>
<div class="container one-bottom" >
  <h4 >Team & Contributions</h4>
  <h5 >Ryan Carriere</h5>
  <p >Ryan Carriere contributed to creating the graphs in the Blue Bikes today section. Also helped with coding.</p>
  <h5>Coral Rembert</h5>
  <p>Coral Rembert contributed to creating the Github page, finding data and figuring out what data to represent, research question, page layout and narrative organization, impact section verbage, and adding pictures.</p>
  <h5 >Anibal Robles</h5>
  <p >Anibal Robles contributed to creating the interactive graphs, implementing the multiple csv files for getting data, and implementing the chord graph.</p>
  <h5 >Brian Ferrell</h5>
  <p >Brian Ferrell contributed to creating diagrams with Boston and BlueBikes data using GIS programs, webpage layout, research, presentation, and introduction. </p>
</div>
<script>
// set the dimensions and margins of the graph
L.mapbox.accessToken = 'pk.eyJ1IjoiZGltcCIsImEiOiJkRnlra3RjIn0.E9CTYzNUEx0yb3dcfV4SiA';

var margin = {top: 200, right: 30, bottom: 200, left: 60},
  width = 650 - margin.left - margin.right,
  height = 600 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

//These are the variables that contain the id of the clicked station.
var stationId17 = 0;
var stationId19 = 0;
var currentData2017 = null;
var currentData2019 = null;

//Creation of both 2d maps (2017, 2019).
d3.csv("201706-hubway-tripdata.csv", function(tripData2017) {
  d3.csv("201906-bluebikes-tripdata.csv", function(tripData2019) {


    var parseTime = d3.timeParse("%Y-%m-%d %H:%M:%S");

    var trips2017 = tripData2017.map(function(aData)
    {
      var trip = {};

      //trip.starttime = d3.timeFormat("%Y-%m-%d %H:%M:%S");
      trip.starttime = parseTime(aData["starttime"].slice(0,-5));
      //trip.stoptime = d3.timeFormat("%Y-%m-%d %H:%M:%S")
      trip.stoptime = parseTime(aData["stoptime"].slice(0,-5));
      trip.duration = +aData["tripduration"];
      trip.start_station = +aData["start station id"];
      trip.end_station = +aData["end station id"];
      trip.start_station_name = aData["start station name"];
      trip.end_station_name = aData["end station name"];
      trip.start_station_lat = +aData["start station latitude"];
      trip.end_station_lat = +aData["end station latitude"];
      trip.start_station_lng = +aData["start station longitude"];
      trip.end_station_lng = +aData["end station longitude"];
      trip.bikeid = +aData["bikeid"];
      trip.usertype = aData["usertype"];
      
      return trip;
    });

    var trips2019 = tripData2019.map(function(aData)
    {
      var trip = {};

      //trip.starttime = d3.timeFormat("%Y-%m-%d %H:%M:%S").parse(aData["starttime"].slice(0,-5));
      trip.starttime = parseTime(aData["starttime"].slice(0,-5));
      //trip.stoptime = d3.timeFormat("%Y-%m-%d %H:%M:%S").parse(aData["stoptime"].slice(0,-5));
      trip.stoptime = parseTime(aData["stoptime"].slice(0,-5));
      trip.duration = +aData["tripduration"];
      trip.start_station = +aData["start station id"];
      trip.end_station = +aData["end station id"];
      trip.start_station_name = aData["start station name"];
      trip.end_station_name = aData["end station name"];
      trip.start_station_lat = +aData["start station latitude"];
      trip.end_station_lat = +aData["end station latitude"];
      trip.start_station_lng = +aData["start station longitude"];
      trip.end_station_lng = +aData["end station longitude"];
      trip.bikeid = +aData["bikeid"];
      trip.usertype = aData["usertype"];
      
      return trip;
    });

    // Only getting the information needed from csv file (parsing even more).
    stations2017 = getStationsFromTrips(trips2017);
    stations2019 = getStationsFromTrips(trips2019);

    var map_1 = L.mapbox.map('map_1')
      .setView([42.3601,-71.0589], 12)
      .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10'));
      map_1
      .scrollWheelZoom.disable();

    stations2017.forEach(function(station){
      
      //Creating a layer for the markers to be able to get the 'event' when they are clicked.
      //Sourced from: 
      //https://gis.stackexchange.com/a/172586 
      var markersLayer = L.featureGroup().addTo(map_1);
      station.lat = +station.lat;
      station.lng = +station.lng;
      
      var path_options = {};

      path_options = {
        radius :  6,
        color : d3.rgb(16,52,166).brighter(),
        stroke: true,
        weight : 1,
        fill : true,
        Color: d3.rgb(16,52,166).brighter(),
      };

      L.circleMarker([station.lat, station.lng], path_options).addTo(markersLayer).bindPopup(
          "Station Name: " + station.name 
          + "<br>Station ID: </br>" + station.station_id);  

      markersLayer.on("click", function (event) {
        var clickedMarker = event.layer;
        console.log(station.station_id);
        stationId17 = station.station_id;
      });
      
      /* L.circleMarker([station.lat, station.lng], path_options).addTo(markersLayer).bindPopup(
      station.station_id);
      markersLayer.on("click", function (event) {
          var clickedMarker = event.layer;
          console.log(clickedMarker)
      }); */
    });

    var map_2 = L.mapbox.map('map_2')
      .setView([42.3601,-71.0589], 12)
      .addLayer(L.mapbox.styleLayer('mapbox://styles/mapbox/light-v10'));
      map_2
      .scrollWheelZoom.disable();

    stations2019.forEach(function(station){
      
      //Creating a layer for the markers to be able to get the 'event' when they are clicked.
      //Sourced from: 
      //https://gis.stackexchange.com/a/172586 
      var markersLayer = L.featureGroup().addTo(map_2);
      station.lat = +station.lat;
      station.lng = +station.lng;
      
      var path_options = {};

      path_options = {
        radius :  6,
        color : d3.rgb(166,16,16).brighter(),
        stroke: true,
        weight : 1,
        fill : true,
        Color: d3.rgb(166,16,16).brighter(),
      };

      L.circleMarker([station.lat, station.lng], path_options).addTo(markersLayer).bindPopup(
          "Station Name: " + station.name 
          + "<br>Station ID: </br>" + station.station_id);  

      markersLayer.on("click", function (event) {
        var clickedMarker = event.layer;
        console.log(station.station_id);
        stationId19 = station.station_id;
      });
      
    });

  });
});

/* d3.csv("201906 - longest.csv", function(data) {


    var nodeNames = data.map(function(d){return d.name})

    var id = data.map(function(d){return d.id})

    var size = d3.scaleLinear()
      .domain([1,30])
      .range([2,30]);

    var x = d3.scalePoint()
      .range([0, width])
      .domain(nodeNames)

      var idToNode = {};
      data.forEach(function (n) {
        idToNode[n.id] = n;
      });


      // Add the links
      var links = svg
        .selectAll('mylinks')
        .data(data)
        .enter()
        .append('path')
        .attr('d', function (d) {
          start = x(idToNode[d.source].name)    // X position of start node on the X axis
          end = x(idToNode[d.target].name)      // X position of end node
          return ['M', start, height-30,    // the arc starts at the coordinate x=start, y=height-30 (where the starting node is)
            'A',                            // This means we're gonna build an elliptical arc
            (start - end)/2, ',',    // Next 2 lines are the coordinates of the inflexion point. Height of this point is proportional with start - end distance
            (start - end)/2, 0, 0, ',',
            start < end ? 1 : 0, end, ',', height-30] // We always want the arc on top. So if end is before start, putting 0 here turn the arc upside down.
            .join(' ');
        })
        .style("fill", "none")
        .attr("stroke", "grey")
        .style("stroke-width", 1)


        var allID = data.map(function(d){return d.id})
        allID = [...new Set(allID)]

        var color = d3.scaleOrdinal()
          .domain(allID)
          .range(d3.schemeSet3);

        var nodes = svg
          .selectAll("mynodes")
          .data(data.sort(function(a,b) { return +b.n - +a.n }))
          .enter()
          .append("circle")
            .attr("cx", function(d){ return(x(d.name))})
            .attr("cy", height-30)
            .attr("r", function(d){ return(size(d.weight))})
            //.style("fill", function(d){ return color(d.id)})
            .attr("stroke", "white")

            var labels = svg
              .selectAll("mylabels")
              .data(data)
              .enter()
              .append("text")
                .attr("x", 0)
                .attr("y", 0)
                .text(function(d){ return(d.name)} )
                .style("text-anchor", "end")
                .attr("transform", function(d){ return( "translate(" + (x(d.name)) + "," + (height-15) + ")rotate(-45)")})
                .style("font-size", 6)

                nodes
                  .on('mouseover', function (d) {
                    // Highlight the nodes: every node is green except of him
                    nodes
                      .style('opacity', .2)
                    d3.select(this)
                      .style('opacity', 1)
                    // Highlight the connections
                    links
                      .style('stroke', function (link_d) { return link_d.source === d.id || link_d.target === d.id ? color(d.id) : '#b8b8b8';})
                      .style('stroke-opacity', function (link_d) { return link_d.source === d.id || link_d.target === d.id ? 1 : .2;})
                      .style('stroke-width', function (link_d) { return link_d.source === d.id || link_d.target === d.id ? 4 : 1;})
                    labels
                      .style("font-size", function(label_d){ return label_d.name === d.name ? 16 : 2 } )
                      .attr("y", function(label_d){ return label_d.name === d.name ? 10 : 0 } )

                  })
                  .on('mouseout', function (d) {
                    nodes.style('opacity', 1)
                    links
                      .style('stroke', 'grey')
                      .style('stroke-opacity', .8)
                      .style('stroke-width', '1')
                    labels
                      .style("font-size", 4 )

                  })

}); */

var t17 = null;
var t19 = null;
var b17 = null;
var b19 = null;

// Average times, create bar graphs.
d3.csv("averageTimePerMonth_2017.csv", function(trip_2017Data){
  d3.csv("averageTimePerMonth_2019.csv", function(trip_2019Data){   
    var t1 = trip_2017Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    var t2 = trip_2019Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    
    t17 = t1
    t19 = t2
    update(t17)
  });
});

// Average times, create bar graphs.
d3.csv("totalTripsPerMonth_2017.csv", function(trip_2017Data){
  d3.csv("totalTripsPerMonth_2019.csv", function(trip_2019Data){   
    var t1 = trip_2017Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    var t2 = trip_2019Data.map(function(aData)
    {
      var trip = {};

      trip.month = aData["month"];
      trip.value = +aData["value"];
      return trip;
    });
    
    b17 = t1
    b19 = t2
    updateTrip(b17)
  });
});
//From: https://stackoverflow.com/a/56216283 
/* (async() => {
    console.log("waiting for variable");
    while(!window.hasOwnProperty("t17") || !window.hasOwnProperty("t19")) // define the condition as you like
        await new Promise(resolve => setTimeout(resolve, 1000));
    console.log("variable is defined");
})();
console.log("above code doesn't block main function stack"); */

// set the dimensions and margins of the graph
var barMargin = {top: 30, right: 30, bottom: 70, left: 60},
    barWidth = 460 - barMargin.left - barMargin.right,
    barHeight = 400 - barMargin.top - barMargin.bottom;


// append the svg object to the body of the page
var barSvg = d3.select("#tripDurationBarGraph")
  .append("svg")
    .attr("width", barWidth + barMargin.left + barMargin.right)
    .attr("height", barHeight + barMargin.top + barMargin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + barMargin.left + "," + barMargin.top + ")");

// append the svg object to the body of the page
var barSvg2 = d3.select("#totalTripsBarGraph")
  .append("svg")
    .attr("width", barWidth + barMargin.left + barMargin.right)
    .attr("height", barHeight + barMargin.top + barMargin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + barMargin.left + "," + barMargin.top + ")");


// Initialize the X axis
var barX = d3.scaleBand()
  .range([ 0, barWidth ])
  .padding(0.2);
var barXAxis = barSvg.append("g")
  .attr("transform", "translate(0," + barHeight + ")")

// Initialize the Y axis
var barY = d3.scaleLinear()
  .range([ barHeight, 0]);
var barYAxis = barSvg.append("g")
  .attr("class", "myYaxis")


// Initialize the X axis
var barX2 = d3.scaleBand()
  .range([ 0, barWidth ])
  .padding(0.2);
var barXAxis2 = barSvg2.append("g")
  .attr("transform", "translate(0," + barHeight + ")")

// Initialize the Y axis
var barY2 = d3.scaleLinear()
  .range([ barHeight, 0]);
var barYAxis2 = barSvg2.append("g")
  .attr("class", "myYaxis")

  // A function that create / update the plot for a given variable:
  function update(data) {

    console.log(data)
    // Update the X axis
    barX.domain(data.map(function(d) { return d.month; }))
    barXAxis.call(d3.axisBottom(barX))

    // Update the Y axis
    barY.domain([0, d3.max(data, function(d) { return d.value }) ]);
    barYAxis.transition().duration(1000).call(d3.axisLeft(barY));

    // Create the u variable
    var u = barSvg.selectAll("rect")
      .data(data)

    u
      .enter()
      .append("rect") // Add a new rect for each new elements
      .merge(u) // get the already existing elements as well
      .transition() // and apply changes to all of them
      .duration(1000)
        .attr("x", function(d) { return barX(d.month); })
        .attr("y", function(d) { return barY(d.value); })
        .attr("width", barX.bandwidth())
        .attr("height", function(d) { return barHeight - barY(d.value); })
        .attr("fill", "#8355ed")

      // If less group in the new dataset, I delete the ones not in use anymore
      u
      .exit()
      .remove()
  }
  function waitForElement(){
    if((typeof t17 !== "undefined") || (typeof t19 !== "undefined")){
        //variable exists, do what you want
        return;
    }
    else{
        setTimeout(waitForElement, 250);
    }
  }

  // A function that create / update the plot for a given variable:
  function updateTrip(data) {

      console.log(data)
      // Update the X axis
      barX2.domain(data.map(function(d) { return d.month; }))
      barXAxis2.call(d3.axisBottom(barX2))

      // Update the Y axis
      barY2.domain([0, d3.max(data, function(d) { return d.value }) ]);
      barYAxis2.transition().duration(1000).call(d3.axisLeft(barY2));

      // Create the u variable
      var u = barSvg2.selectAll("rect")
        .data(data)

      u
        .enter()
        .append("rect") // Add a new rect for each new elements
        .merge(u) // get the already existing elements as well
        .transition() // and apply changes to all of them
        .duration(1000)
          .attr("x", function(d) { return barX2(d.month); })
          .attr("y", function(d) { return barY2(d.value); })
          .attr("width", barX2.bandwidth())
          .attr("height", function(d) { return barHeight - barY2(d.value); })
          .attr("fill", "#8355ed")

        // If less group in the new dataset, I delete the ones not in use anymore
        u
        .exit()
        .remove()
      }
  function waitForElement2(){
    if((typeof b17 !== "undefined") || (typeof b19 !== "undefined")){
        //variable exists, do what you want
        return;
    }
    else{
        setTimeout(waitForElement2, 250);
    }
  } 

  function getStationsFromTrips(trips){
          var stations = [];
          var indexByStationName = d3.map();
          var StationNameByIndex = d3.map();
          var n = 0;
          trips.forEach(function(trip) {
            
            if (!indexByStationName.has(trip.start_station)) {
              stations.push({
                station_id : trip.start_station,
                name : trip.start_station_name,
                lat : trip.start_station_lat,
                lng : trip.start_station_lng,
              });
              StationNameByIndex.set(n, trip.start_station);
              indexByStationName.set(trip.start_station, n++);
            }
            if (!indexByStationName.has(trip.end_station)) {
              stations.push({
                station_id : trip.end_station,
                name : trip.end_station_name,
                lat : trip.end_station_lat,
                lng : trip.end_station_lng,
              });
              StationNameByIndex.set(n, trip.end_station);
              indexByStationName.set(trip.end_station, n++);
            }

          });
          number_of_stations = n;
          return stations;
        }

  // Initialize the plot with the first dataset
  waitForElement()
  
var heatMargin = {top: 30, right: 30, bottom: 70, left: 70},
  heatWidth = 950 - heatMargin.left - heatMargin.right,
  heatHeight = 900 - heatMargin.top - heatMargin.bottom;

// append the svg object to the body of the page
var heatSvg = d3.select("#heatmap")
.append("svg")
  .attr("width", heatWidth + heatMargin.left + heatMargin.right)
  .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
.append("g")
  .attr("transform",
        "translate(" + heatMargin.left + "," + heatMargin.top + ")");


//Read the data
d3.csv("201706-longest-heatmap.csv", function(heat_2017data) {

  // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
  var myGroups = d3.map(heat_2017data, function(d){return d.start_station_id;}).keys()
  var myVars = d3.map(heat_2017data, function(d){return d.end_station_id;}).keys()

  // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
    heatSvg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
    heatSvg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0)) 

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  heatSvg.selectAll()
    .data(heat_2017data, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseleave", mouseleave)

  });
  //updateHeatmap17("201706-longest-heatmap.csv");
 
  
  
  //Heatmap2
  function updateHeatmap17(fileName)
{
  document.getElementById("heatmap").innerHTML = ""; 
  // set the dimensions and margins of the graph
var heatMargin = {top: 30, right: 30, bottom: 70, left: 70},
  heatWidth = 950 - heatMargin.left - heatMargin.right,
  heatHeight = 900 - heatMargin.top - heatMargin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#heatmap")
.append("svg")
  .attr("width", heatWidth + heatMargin.left + heatMargin.right)
  .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
.append("g")
  .attr("transform",
        "translate(" + heatMargin.left + "," + heatMargin.top + ")");

//Read the data
d3.csv(fileName, function(heat_2019data) {


  // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
  var myGroups = d3.map(heat_2019data, function(d){return d.start_station_id;}).keys()
  var myVars = d3.map(heat_2019data, function(d){return d.end_station_id;}).keys()

  // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
  svg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
  svg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0))
    
    

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  svg.selectAll()
    .data(heat_2019data, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseleave", mouseleave)

});
}      
// https://bl.ocks.org/iblind/b394c943fef0aedc569d 
function updateHeatmap17(fileName)
{
  document.getElementById("heatmap").innerHTML = "";
  // append the svg object to the body of the page
  var heatSvg = d3.select("#heatmap")
  .append("svg")
    .attr("width", heatWidth + heatMargin.left + heatMargin.right)
    .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + heatMargin.left + "," + heatMargin.top + ")");
  //Get data, in this case, sorting csv file.
  d3.csv(fileName, function(heat17) {
    myGroups = d3.map(heat17, function(d){return d.start_station_id;}).keys()
    myVars = d3.map(heat17, function(d){return d.end_station_id;}).keys()

     // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
    heatSvg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
    heatSvg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0)) 

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  heatSvg.selectAll()
    .data(heat17, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .transition().duration(100)
      .style("fill", function(d) { return myColor(d.tripduration)} )
      //.style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)

    
  });
}

// https://bl.ocks.org/iblind/b394c943fef0aedc569d 
function updateHeatmap17(fileName)
{
  document.getElementById("heatmap").innerHTML = "";
  // append the svg object to the body of the page
var svg = d3.select("#heatmap")
.append("svg")
  .attr("width", heatWidth + heatMargin.left + heatMargin.right)
  .attr("height", heatHeight + heatMargin.top + heatMargin.bottom)
.append("g")
  .attr("transform",
        "translate(" + heatMargin.left + "," + heatMargin.top + ")");
  //Get data, in this case, sorting csv file.
  d3.csv(fileName, function(heat19) {
    myGroups = d3.map(heat19, function(d){return d.start_station_id;}).keys()
    myVars = d3.map(heat19, function(d){return d.end_station_id;}).keys()

  // Build X scales and axis:
  var xheat = d3.scaleBand()
    .range([ 0, heatWidth])
    .domain(myGroups)
    .padding(.05);
  svg.append("g")
    .style("font-size", 5)
    .attr("transform", "translate(0," + heatHeight + ")")
    .call(d3.axisBottom(xheat).tickSize(0))
    .selectAll("text")
    .attr("transform", "translate(-10,10)rotate(-90)")

  // Build Y scales and axis:
  var yheat = d3.scaleBand()
    .range([ heatHeight, 0 ])
    .domain(myVars)
    .padding(0.05);
  svg.append("g")
    .style("font-size",5)
    .call(d3.axisLeft(yheat).tickSize(0))
    

  // Build color scale
  var myColor = d3.scaleSequential()
    .interpolator(d3.interpolateInferno)
    .domain([1,10000])

  // create a tooltip
  var tooltip = d3.select("#heatmap2")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "2px")
    .style("border-radius", "5px")
    .style("padding", "5px")

  // Three function that change the tooltip when user hover / move / leave a cell
  var mouseover = function(d) {
    tooltip
      .style("opacity", 1)
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 1)
  }
  var mousemove = function(d) {
    tooltip
      .html("The duration of this Trip is: " + d.tripduration + "<br>Start Station: " + d.start_station_name + "<br>End Station: " + d.end_station_name)
      .style("left", (d3.mouse(this)[0]+70) + "px")
      .style("top", (d3.mouse(this)[1]) + "px")
  }
  var mouseleave = function(d) {
    tooltip
      .style("opacity", 0)
    d3.select(this)
      .style("stroke", "none")
      .style("opacity", 0.8)
  }

  // add the squares
  svg.selectAll()
    .data(heat19, function(d) {return d.start_station_id+':'+d.end_station_id;})
    .enter()
    .append("rect")
      .attr("x", function(d) { return xheat(d.start_station_id) })
      .attr("y", function(d) { return yheat(d.end_station_id) })
      .attr("rx", 4000)
      .attr("ry", 4000)
      .attr("width", xheat.bandwidth() )
      .attr("height", yheat.bandwidth() )
      .style("fill", function(d) { return myColor(d.tripduration)} )
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)
    .on("mouseover", mouseover)
    .on("mousemove", mousemove)
    .on("mouseleave", mouseleave)

    
  });
}

function updateByStationIndex(anIndex)
{
  
}

</script>


  </body>
  </html>



Introduction
Boston’s bike sharing system, Hubway, launched in July of of 2011 with 610 bicycles and 61 stations covering a footprint of approximately 20 square miles in downtown Boston and its immediately surrounding neighborhoods. The system was designed to operate in three seasons and later shifted to year-round service for some locations. Brookline, Cambridge, and Somerville launched stations in 2012, and Hubway rides continued to grow exponentially. By 2014, Hubway had 140 stations and 1,300 bikes with around 10,000 annual memberships. The service had sold 79,000 Day Passes, 9,000 3-Day Passes, and 2,000 Monthly Memberships in the previous year. From 2015 to 2016, Hubway expanded to more neighborhoods in Boston and Cambridge. Before Hubway’s rebranding to Bluebikes, the system had expanded to include 185 stations with 1800 bicycles.

Expansion and Transformation
In 2017, Hubway announced a large expansion that would fill in the current network and expand to new neighboring areas. In the following year, Blue Cross Blue Shield of Massachusetts sponsored the system and Hubway was rebranded to BlueBikes with an addition of 100 stations and expansion to 3000 bikes. With the systems rebranding, the pricing structure and subscription was changed. Hubway offered free rides under 30 minutes, daily passes for $8, three-day passes for $12, and a choice between a $20 monthly pass and a $99 yearly membership for regular users. Low income residents and employees at sponsored companies received discounted or subsidized memberships. As a result,  Hubway’s pricing model favored users who took shorter trips, with casual 1-day pass users paying more per trip than yearly members. Hubway also favored shorter trips by charging fees after the first 30 minutes of a trip. The fees were larger for 24 and 72 hour pass riders than for monthly and yearly members. The transition to Bluebikes introduced a pricing model that encouraged long-term membership, with increased availability year-round. Bluebikes switched to offering $10 one day passes, $25 monthly passes, and $109 annual memberships without the free 30 minute rides for non-members. This project investigates the strategies that the service is using in its expansion with changes in pricing structure and additional stations. By analyzing trip data from June 2017 before the transition to Bluebikes and June 2019 after the expansion, we can test if the rebranding to Bluebikes and the changes in pricing structure influenced user behavior including trip duration, the stations with the most traffic, and the overall number of trips in the month.

Heatmap

These heatmaps sort the trip data from June 2017 and June 2019 by highest trip duration and by station id. Each station id and its corresponding location for each data set is shown in the maps above, In each heatmap, the x axis represents the start location of the trip and the y axis represents the end location. Darker colors represent shorter trips, while lighter colors represent longer trips. 
